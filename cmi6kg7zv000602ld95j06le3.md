---
title: "Terraform From Zero to Advanced: A Beginner-Friendly Guide"
datePublished: Wed Nov 19 2025 22:20:38 GMT+0000 (Coordinated Universal Time)
cuid: cmi6kg7zv000602ld95j06le3
slug: terraform-from-zero-to-advanced-a-beginner-friendly-guide
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1763588246616/c8e2da25-5bc9-4da7-9042-3d5c77ed15d0.png
tags: devops, terraform, 90daysofdevops

---

## Introduction

Terraform is one of the most powerful tools for Infrastructure as Code (IaC). It allows you to create, change, and manage cloud resources using simple configuration files. Whether you're deploying an EC2 instance, an S3 bucket, or an entire VPC, Terraform makes everything repeatable, automated, and error‑free.

This guide will walk you through Terraform from absolute basics to advanced concepts in the simplest possible way.

## Table of Contents

1. What is Terraform?
    
2. Why Terraform?
    
3. How Terraform Works
    
4. Terraform Architecture
    
5. Terraform Configuration Blocks
    
6. Providers
    
7. Arguments & Meta‑Arguments
    
8. Variables
    
9. Outputs
    
10. Locals
    
11. Modules
    
12. Terraform State
    
13. Remote Backends
    
14. Workspaces
    
15. Terraform Lifecycle
    
16. Provisioners
    
17. Data Sources
    
18. Common Terraform Commands
    
19. Terraform Code – Create an EC2 Instance
    
20. Terraform Code – Create an S3 Bucket
    
21. Terraform Code – Create a VPC, Subnet, IGW, Route Table (Basic Setup)
    
22. Conclusion
    

## 1\. What is Terraform?

Terraform is an Infrastructure as Code tool that lets you define cloud resources (AWS, Azure, GCP, etc.) in `.tf` files using simple syntax. Instead of clicking buttons in the console, you write code.

Terraform reads this configuration and creates the infrastructure exactly as described.

## 2\. Why Terraform?

* **Automation:** No manual setup.
    
* **Consistency:** Same setup everywhere.
    
* **Multi‑Cloud:** Supports almost all cloud platforms.
    
* **Version Control:** You can track changes in Git.
    
* **Reusable:** Write once, reuse multiple times with modules.
    

## 3\. How Terraform Works

Terraform follows a simple workflow:

1. **Write** (.tf files)
    
2. **Initialize** (`terraform init`)
    
3. **Validate** (`terraform validate`)
    
4. **Plan** (`terraform plan`)
    
5. **Apply** (`terraform apply`)
    
6. **Destroy** (`terraform destroy`)
    

Terraform takes your desired state (what you wrote) and matches it with actual state (what exists), then applies changes.

## 4\. Terraform Architecture

Terraform is made of:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763589684005/61ced1b1-6166-4ac1-b205-b74fc906e5a5.png align="center")

| Components | Purpose (Explanation) |
| --- | --- |
| **Core Engine** | Reads your `.tf` files, compares desired vs. actual state, and creates an execution plan. |
| **Providers** | Plugins that allow Terraform to interact with cloud/platform APIs (AWS, Azure, GCP, GitHub, Kubernetes, etc.). |
| **State File** | Stores information about real resources so Terraform knows what already exists and what needs changes. |
| **Backend** | Determines where the state file is stored (local machine, S3 bucket, Terraform Cloud, etc.). |

## 5\. Terraform Configuration Blocks

Terraform uses different blocks in `.tf` files:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763589994156/c57b180e-54b5-415c-aab4-787375282b79.png align="center")

| Block Names | Purpose (Explanation) |
| --- | --- |
| **terraform** | Configures Terraform settings like required providers and versions. |
| **provider** | Tells Terraform which cloud/platform to connect with (AWS, Azure, GCP, GitHub, etc.). |
| **resource** | Creates actual infrastructure (EC2, S3, VPC, IAM, etc.). |
| **variable** | Stores input values to make configuration reusable and dynamic. |
| **output** | Prints important values after deployment (IP addresses, IDs). |
| **module** | Calls reusable sets of Terraform code. |
| **data** | Reads existing data/resources from the cloud (without creating anything). |
| **locals** | Stores local values/expressions inside the config (like small helper variables). |

# Install Terraform (Linux – Ubuntu/Debian)

```plaintext
sudo apt update
sudo apt install -y gnupg software-properties-common

wget -O- https://apt.releases.hashicorp.com/gpg | \
sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
sudo tee /etc/apt/sources.list.d/hashicorp.list

sudo apt update
sudo apt install -y terraform
```

Check version:

```plaintext
terraform -version
```

## 6\. Providers

* **Providers are plugins that teach Terraform how to talk to a cloud or service.**  
    It knows **how to create, update, delete, and manage** resources for a specific platform.
    

Example providers include:

* AWS
    
* Azure
    
* Google Cloud
    
* GitHub
    
* Kubernetes
    
* Docker
    

Each provider contains the logic + API calls needed to manage resources.

* ## **Why Terraform Needs Providers?**
    

Terraform itself does NOT know how to:

* create an EC2 instance
    
* create an S3 bucket
    
* create a VPC
    
* update an IAM policy
    

All of this knowledge comes from the **provider plugin**.

So Terraform acts like the “brain,”  
and the provider is the “hands” that perform the actual API calls.

Example:

```plaintext
provider "aws" {
  region     = "us-west-2"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}
```

Terraform automatically downloads providers during `terraform init`.

* ## Terraform provider Documentation say
    

1. **Providers are the bridge** between Terraform and the actual service API.
    
2. Providers support **resources** (things you create or manage).
    
3. Providers support **data sources** (things you read from the cloud).
    
4. Providers can be configured once or multiple times.
    
5. Providers are downloaded via `terraform init`.
    

## 7\. Arguments & Meta‑Arguments

### **Arguments**

Regular properties inside a resource.

Example:

```plaintext
ami           = "ami-123456"
instance_type = "t2.micro"
```

### **Meta‑Arguments**

Special features Terraform gives you:

* `count`
    
* `for_each`
    
* `depends_on`
    

## **count**

* Used to create **multiple copies** of the same resource.
    
* Uses a **number** (0, 1, 2, …).
    
* Good for conditional creation (`count = 0` = don’t create).
    

**Example:**

```plaintext
count = 2
```

Creates 2 resources.

## **for\_each**

* Used to create resources for **each item** in a list or map.
    
* Gives **stable names/keys** instead of indexes.
    
* Better than `count` when each item has an identity (name).
    

**Example:**

```plaintext
for_each = { dev = "10.0.0.1", prod = "10.0.0.2" }
```

## **depends\_on**

* Forces Terraform to **create things in order**.
    
* Used when Terraform cannot detect the dependency on its own.
    

**Example:**

```plaintext
depends_on = [aws_s3_bucket.logs]
```

This resource waits for the bucket to be created.

## 8\. Variables

Variables let you make your configuration reusable.

Example:

```plaintext
variable "instance_type" {
  default = "t2.micro"
}
```

## 9\. Outputs

Outputs show useful information after apply.

Example:

```plaintext
output "public_ip" {
  value = aws_instance.my_ec2.public_ip
}
```

## 10\. Locals

Locals store calculated values.

Example:

```plaintext
locals {
  project = "devops-app"
}
```

Usage:

```plaintext
name = local.project
```

## 11\. Modules

Modules are reusable groups of Terraform files.

Example structure:

```plaintext
modules/ec2/main.tf
modules/ec2/variables.tf
modules/ec2/outputs.tf
```

You call them like:

```plaintext
module "my_ec2" {
  source = "./modules/ec2"
}
```

## 12\. Terraform State

State tracks what Terraform created.

### Why state is important:

* Keeps mapping of real resources.
    
* Enables updates instead of recreating everything.
    
* Helps manage complex infra.
    

Local state file: `terraform.tfstate`

## 13\. Remote Backends

Remote backends store state safely in the cloud.

Popular choice: **AWS S3 + DynamoDB**

Example:

```plaintext
backend "s3" {
  bucket = "mytfbucket"
  key    = "state/dev.tfstate"
  region = "ap-south-1"
}
```

## 14\. Workspaces

Workspaces help you manage multiple environments like:

* dev
    
* stage
    
* prod
    

Commands:

```plaintext
terraform workspace new dev
terraform workspace select dev
terraform workspace list
```

## 15\. Terraform Lifecycle

Controls special behaviors of a resource.  
It has 4 important sub-options:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763590735867/bf7d5b30-ed42-4cae-8bfd-98d3bca11689.png align="center")

### **1\. Init (**`terraform init`)

Downloads the required provider plugins and prepares the working directory.

### **2\. Plan (**`terraform plan`)

Shows what Terraform will create, update, or delete — a preview before making changes.

### **3\. Apply (**`terraform apply`)

Executes the plan and actually creates or updates the infrastructure.

### **4\. Destroy (**`terraform destroy`)

Deletes the infrastructure that Terraform created.

Example:

```plaintext
terraform init
terraform plan
terraform apply
terraform destroy
```

## 16\. Provisioners

Used to run **scripts or commands** after a resource is created.

Types:

* `local-exec` → run on your laptop
    
* `remote-exec` → run on EC2 or server
    
* `file` → copy files to server
    

Example:

```plaintext
provisioner "remote-exec" {
  inline = ["sudo apt update"]
}
```

Use provisioners only when absolutely necessary.

## 17\. Data Sources

Data sources help you fetch existing information.

Example:

```plaintext
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]
}
```

## 18\. Common Terraform Commands

### **Initialize**

```plaintext
terraform init
```

### **Validate syntax**

```plaintext
terraform validate
```

### **See what will happen**

```plaintext
terraform plan
```

### **Create resources**

```plaintext
terraform apply
```

### **Destroy everything**

```plaintext
terraform destroy
```

### **Destroy specific resource**

```plaintext
terraform destroy -target=aws_s3_bucket.my_bucket
```

### **Check all managed resources**

```plaintext
terraform state list
```

## 19\. Terraform Code – Create an EC2 Instance

Create a file: [**ec2.tf**](http://ec2.tf)

```plaintext
provider "aws" {
  region = "ap-south-1"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}

resource "aws_instance" "my_ec2" {
  ami           = "ami-0c2b8ca1dad447f8a"        # (Ubuntu image)
  instance_type = "t2.micro"

  tags = {
    Name = "my-ec2-instance"                     # Your server name which you will create.
  }
}
```

Commands:

```plaintext
terraform init
terraform validate
terraform plan
terraform apply
```

## 20\. Terraform Code – Create an S3 Bucket

Create a file: [**s3.tf**](http://s3.tf)

```plaintext
provider "aws" {
  region = "ap-south-1"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = "ali-demo-bucket-12345"              # bucket name must be unique globally
tags = {
    Name        = "My bucket"
    Environment = "Dev"                 # It is a custom tag used to identify the environment in which this resource is used."
  }
}
```

## 21\. Terraform Code – Create a VPC, Subnet, IGW, Route Table (Basic Setup)

Create file: [**vpc.tf**](http://vpc.tf)

```plaintext
# AWS Provider Configuration

provider "aws" {
  region     = "ap-south-1"                 # AWS region (Mumbai)
  access_key = "my-access-key"              # Your AWS access key
  secret_key = "my-secret-key"              # Your AWS secret key
}

resource "aws_vpc" "main_vpc" {
  cidr_block = "10.0.0.0/16"            # Main network range for VPC

  tags = {
    Name = "main-vpc"                   # Name tag for identification
  }
}


resource "aws_subnet" "public_subnet" {
  vpc_id                  = aws_vpc.main_vpc.id       # Attach subnet to VPC
  cidr_block              = "10.0.1.0/24"             # Subnet range
  map_public_ip_on_launch = true                      # Auto-assign public IP

  tags = {
    Name = "public-subnet"                            # Tag for subnet
  }
}


resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main_vpc.id                   # Attach IGW to VPC

  tags = {
    Name = "main-igw"                            # Name tag
  }
}

                       
resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.main_vpc.id                       # Attach RT to VPC

  route {
    cidr_block = "0.0.0.0/0"                         # All traffic
    gateway_id = aws_internet_gateway.igw.id         # Send to IGW
  }

  tags = {
    Name = "public-route-table"   # Tag for route table
  }
}

# Route Table Association
# Connect Subnet → Route Table

resource "aws_route_table_association" "public_rt_assoc" {
  subnet_id      = aws_subnet.public_subnet.id                   # Which subnet?
  route_table_id = aws_route_table.public_rt.id                  # Which route table?
}
```

## 22\. Conclusion

Terraform is simple but powerful. By mastering resources, variables, modules, state, backends, and advanced concepts, you can manage any cloud infrastructure with confidence.

Use this guide as your foundation and keep practicing by building real projects like VPCs, EC2 setups, multi-tier architectures, and automated modules.