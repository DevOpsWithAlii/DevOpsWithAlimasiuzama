---
title: "Terraform From Zero to Advanced: A Beginner-Friendly Guide"
datePublished: Wed Nov 19 2025 22:20:38 GMT+0000 (Coordinated Universal Time)
cuid: cmi6kg7zv000602ld95j06le3
slug: terraform-from-zero-to-advanced-a-beginner-friendly-guide
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1763655922423/e3bfc38b-5bf2-4750-937f-2dd4af700e52.png
tags: devops, terraform, 90daysofdevops

---

## Introduction

Terraform is one of the most powerful tools for Infrastructure as Code (IaC). It allows you to create, change, and manage cloud resources using simple configuration files. Whether you're deploying an EC2 instance, an S3 bucket, or an entire VPC, Terraform makes everything repeatable, automated, and error‚Äëfree.

This guide will walk you through Terraform from absolute basics to advanced concepts in the simplest possible way.

## Table of Contents

1. What is Terraform?
    
2. Why Terraform?
    
3. How Terraform Works
    
4. Terraform Architecture
    
5. Terraform Configuration Blocks
    
6. Providers
    
7. Arguments & Meta‚ÄëArguments
    
8. Variables
    
9. Outputs
    
10. Locals
    
11. Modules
    
12. Terraform State
    
13. Remote Backends
    
14. Workspaces
    
15. Terraform Lifecycle
    
16. Provisioners
    
17. Data Sources
    
18. Common Terraform Commands
    
19. Terraform Code ‚Äì Create an EC2 Instance
    
20. Terraform Code ‚Äì Create an S3 Bucket
    
21. Terraform Code ‚Äì Create a VPC, Subnet, IGW, Route Table (Basic Setup)
    
22. Conclusion
    

## 1\. What is Terraform?

Terraform is an Infrastructure as Code tool that lets you define cloud resources (AWS, Azure, GCP, etc.) in `.tf` files using simple syntax. Instead of clicking buttons in the console, you write code.

Terraform reads this configuration and creates the infrastructure exactly as described.

## 2\. Why Terraform?

* **Automation:** No manual setup.
    
* **Consistency:** Same setup everywhere.
    
* **Multi‚ÄëCloud:** Supports almost all cloud platforms.
    
* **Version Control:** You can track changes in Git.
    
* **Reusable:** Write once, reuse multiple times with modules.
    

## 3\. How Terraform Works

Terraform follows a simple workflow:

1. **Write** (.tf files)
    
2. **Initialize** (`terraform init`)
    
3. **Validate** (`terraform validate`)
    
4. **Plan** (`terraform plan`)
    
5. **Apply** (`terraform apply`)
    
6. **Destroy** (`terraform destroy`)
    

Terraform takes your desired state (what you wrote) and matches it with actual state (what exists), then applies changes.

## 4\. Terraform Architecture

Terraform is made of:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763589684005/61ced1b1-6166-4ac1-b205-b74fc906e5a5.png align="center")

| Components | Purpose (Explanation) |
| --- | --- |
| **Core Engine** | Reads your `.tf` files, compares desired vs. actual state, and creates an execution plan. |
| **Providers** | Plugins that allow Terraform to interact with cloud/platform APIs (AWS, Azure, GCP, GitHub, Kubernetes, etc.). |
| **State File** | Stores information about real resources so Terraform knows what already exists and what needs changes. |
| **Backend** | Determines where the state file is stored (local machine, S3 bucket, Terraform Cloud, etc.). |

## 5\. Terraform Configuration Blocks

Terraform uses different blocks in `.tf` files:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763589994156/c57b180e-54b5-415c-aab4-787375282b79.png align="center")

| Block Names | Purpose (Explanation) |
| --- | --- |
| **terraform** | Configures Terraform settings like required providers and versions. |
| **provider** | Tells Terraform which cloud/platform to connect with (AWS, Azure, GCP, GitHub, etc.). |
| **resource** | Creates actual infrastructure (EC2, S3, VPC, IAM, etc.). |
| **variable** | Stores input values to make configuration reusable and dynamic. |
| **output** | Prints important values after deployment (IP addresses, IDs). |
| **module** | Calls reusable sets of Terraform code. |
| **data** | Reads existing data/resources from the cloud (without creating anything). |
| **locals** | Stores local values/expressions inside the config (like small helper variables). |

# Install Terraform (Linux ‚Äì Ubuntu/Debian)

```plaintext
sudo apt update
sudo apt install -y gnupg software-properties-common

wget -O- https://apt.releases.hashicorp.com/gpg | \
sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] \
https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
sudo tee /etc/apt/sources.list.d/hashicorp.list

sudo apt update
sudo apt install -y terraform
```

Check version:

```plaintext
terraform -version
```

## 6\. Providers

* **Providers are plugins that teach Terraform how to talk to a cloud or service.**  
    It knows **how to create, update, delete, and manage** resources for a specific platform.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763655758106/098c0fe6-111e-47fd-b43b-9303a7849f83.png align="center")

Example providers include:

* AWS
    
* Azure
    
* Google Cloud
    
* GitHub
    
* Kubernetes
    
* Docker
    

Each provider contains the logic + API calls needed to manage resources.

* ## **Why Terraform Needs Providers?**
    

Terraform itself does NOT know how to:

* create an EC2 instance
    
* create an S3 bucket
    
* create a VPC
    
* update an IAM policy
    

All of this knowledge comes from the **provider plugin**.

So Terraform acts like the ‚Äúbrain,‚Äù  
and the provider is the ‚Äúhands‚Äù that perform the actual API calls.

Example:

```plaintext
provider "aws" {
  region     = "us-west-2"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}
```

Terraform automatically downloads providers during `terraform init`.

* ## Terraform provider Documentation say
    

1. **Providers are the bridge** between Terraform and the actual service API.
    
2. Providers support **resources** (things you create or manage).
    
3. Providers support **data sources** (things you read from the cloud).
    
4. Providers can be configured once or multiple times.
    
5. Providers are downloaded via `terraform init`.
    

## 7\. Arguments & Meta‚ÄëArguments

### **Arguments**

Regular properties inside a resource.

Example:

```plaintext
ami           = "ami-123456"
instance_type = "t2.micro"
```

### **Meta‚ÄëArguments**

Special features Terraform gives you:

* `count`
    
* `for_each`
    
* `depends_on`
    

## **count**

* Used to create **multiple copies** of the same resource.
    
* Uses a **number** (0, 1, 2, ‚Ä¶).
    
* Good for conditional creation (`count = 0` = don‚Äôt create).
    

**Example:**

```plaintext
count = 2
```

Creates 2 resources.

## **for\_each (Create multiple resources using names/keys)**

`for_each` is used when you want to create **multiple resources**, and each item has its own identity (name, key, tag, etc.).

### **Why use for\_each?**

* Creates resources based on a **map or set**
    
* Gives **stable names** (unlike `count`, where indexes can shift)
    
* Best when each resource has a **unique key**
    

### **Example**

```plaintext
resource "aws_instance" "servers" {
  for_each = {
    dev  = "t2.micro"
    prod = "t2.small"
  }

  instance_type = each.value
  tags = {
    Name = each.key
  }
}
```

This creates 2 EC2 instances:  
‚úî One named **dev**  
‚úî One named **prod**

## **depends\_on (Force resource ordering)**

`depends_on` tells Terraform:  
üëâ "**Create this only after another resource is done.**"

Terraform usually detects dependencies automatically, but sometimes you must **force** it.

### **Why use depends\_on?**

* When Terraform cannot detect connection
    
* When resources are logically connected but not referenced directly
    
* Ensures proper ordering
    

### **Example**

```plaintext
resource "aws_s3_bucket" "logs" {
  bucket = "my-logs-bucket"
}

resource "aws_iam_role" "role" {
  name = "logging-role"

  depends_on = [aws_s3_bucket.logs]   # Wait for bucket
}
```

The IAM role waits until the S3 bucket is created.

## 8\. **Variables (Reusable values)**

Variables make Terraform **flexible and reusable**.  
You define them once, use them everywhere.

### **Example**

```plaintext
variable "instance_type" {
  default = "t2.micro"
}
```

### **Usage**

```plaintext
instance_type = var.instance_type
```

### Types of variables

* string
    
* number
    
* bool
    
* list
    
* map
    
* object
    

## 9\. **Outputs (Show values after apply)**

Outputs give you important details after Terraform creates infrastructure.

### **Why use outputs?**

* Show public IP
    
* Show VPC ID
    
* Show S3 bucket name
    
* Pass values to modules
    
* Pass values to other automation tools (Jenkins, Ansible, GitHub Actions)
    

### **Example**

```plaintext
output "public_ip" {
  value = aws_instance.my_ec2.public_ip
}
```

## 10\. **Locals (Store calculated values)**

Locals are like **small helper variables** used inside the configuration.

### **Why locals?**

* Reduce repetition
    
* Store computed values
    
* Make code clean
    

### **Example**

```plaintext
locals {
  project   = "devops-app"
  full_name = "${local.project}-server"
}
```

### **Usage**

```plaintext
tags = {
  Name = local.full_name
}
```

## 11**. Modules (Reusable Terraform components)**

Modules allow you to **organize** Terraform code and **reuse it**.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763655416919/f0f388bc-3e50-4609-ac5b-dfa1fe2fdfcc.jpeg align="center")

### **Why use modules?**

* Clean folder structure
    
* Reusable templates
    
* Production-ready design
    
* Easier maintenance
    

### **Example: Module Folder Structure**

```
modules/
  ec2/
    main.tf
    variables.tf
    outputs.tf
```

### **Calling the module**

```plaintext
module "my_ec2" {
  source = "./modules/ec2"
  instance_type = "t2.micro"
}
```

### **Modules are like functions**

You write code once ‚Üí use many times.

## 12\. Terraform State

Terraform State is the **brain** of Terraform.  
It keeps track of everything Terraform creates in the real cloud.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763654816474/4180a6fa-214f-4c7b-b958-15a09055e53f.jpeg align="center")

### **Why does Terraform need state?**

Terraform uses state to understand:

* **What resources already exist**
    
* **Which resources it manages**
    
* **What needs to be updated, destroyed, or ignored**
    
* **The relationship between your** `.tf` files and actual AWS resources
    

Without state, Terraform would have **no memory** and would recreate everything each time.

### **Local State File**

Terraform stores state locally by default:

```plaintext
terraform.tfstate
```

## 13\. Remote Backends

A backend is where Terraform stores the **state file**.

Remote backends make Terraform state:

Safe  
Shareable  
Locked (so two people cannot run Terraform at the same time)  
Version-controlled

### **Most popular backend**

‚û°Ô∏è **AWS S3 + DynamoDB (for state locking)**

### **Example Backend Configuration**

```
terraform {
  backend "s3" {
    bucket         = "mytfbucket"
    key            = "state/dev.tfstate"
    region         = "ap-south-1"
    dynamodb_table = "tf-state-lock"
  }
}
```

### What this does:

* Stores state in **S3 bucket**
    
* Locks state using **DynamoDB**
    
* Prevents two DevOps engineers from running `terraform apply` at the same time
    

This is a **must** for production.

## 14\. Workspaces

Workspaces let you run **multiple environments** (dev, stage, prod) using the **same Terraform code**.

### Why workspaces?

You don‚Äôt need separate folders or duplicate files.

Example:

* dev
    
* stage
    
* prod
    

Each workspace gets its **own state file**, like:

```plaintext
terraform.tfstate.d/dev/terraform.tfstate
terraform.tfstate.d/prod/terraform.tfstate
```

Commands:

```plaintext
terraform workspace new dev                      #Create a workspace
terraform workspace select dev                   #Switch workspace
terraform workspace list                         #List all workspaces
```

## 15\. Terraform Lifecycle

Controls special behaviors of a resource.  
It has 4 important sub-options:

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1763590735867/bf7d5b30-ed42-4cae-8bfd-98d3bca11689.png align="center")

### **1\. Init (**`terraform init`)

Downloads the required provider plugins and prepares the working directory.

### **2\. Plan (**`terraform plan`)

Shows what Terraform will create, update, or delete ‚Äî a preview before making changes.

### **3\. Apply (**`terraform apply`)

Executes the plan and actually creates or updates the infrastructure.

### **4\. Destroy (**`terraform destroy`)

Deletes the infrastructure that Terraform created.

Example:

```plaintext
terraform init                                    # Initialize
terraform plan                                    # See what will happen
terraform apply                                   # Create resources
terraform destroy                                 # Destroy everything
```

## 16\. Provisioners

Used to run **scripts or commands** after a resource is created.

Types:

* `local-exec` ‚Üí run on your laptop
    
* `remote-exec` ‚Üí run on EC2 or server
    
* `file` ‚Üí copy files to server
    

Example:

```plaintext
provisioner "remote-exec" {
  inline = ["sudo apt update"]
}
```

Use provisioners only when absolutely necessary.

## 17\. Data Sources

Data sources help you fetch existing information.

Example:

```plaintext
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]
}
```

## 18\. Common Terraform Commands

```plaintext
terraform init                                    # Initialize
terraform validate                                # Validate syntax
terraform plan                                    # See what will happen
terraform apply                                   # Create resources
terraform destroy                                 # Destroy everything
terraform destroy -target=aws_s3_bucket.my_bucket    # Destroy specific resource
terraform state list                              # Check all managed resources
```

## 19\. Terraform Code ‚Äì Create an EC2 Instance

Create a file: [**ec2.tf**](http://ec2.tf)

```plaintext
provider "aws" {
  region = "ap-south-1"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}

resource "aws_instance" "my_ec2" {
  ami           = "ami-0c2b8ca1dad447f8a"        # (Ubuntu image)
  instance_type = "t2.micro"

  tags = {
    Name = "my-ec2-instance"                     # Your server name which you will create.
  }
}
```

Commands:

```plaintext
terraform init                                    # Initialize
terraform validate                                # Validate syntax
terraform plan                                    # See what will happen
terraform apply                                   # Create resources
```

## 20\. Terraform Code ‚Äì Create an S3 Bucket

Create a file: [**s3.tf**](http://s3.tf)

```plaintext
provider "aws" {
  region = "ap-south-1"
  access_key = "my-access-key"
  secret_key = "my-secret-key"
}

resource "aws_s3_bucket" "my_bucket" {
  bucket = "ali-demo-bucket-12345"              # bucket name must be unique globally
tags = {
    Name        = "My bucket"
    Environment = "Dev"                 # It is a custom tag used to identify the environment in which this resource is used."
  }
}
```

## 21\. Terraform Code ‚Äì Create a VPC, Subnet, IGW, Route Table (Basic Setup)

Create file: [**vpc.tf**](http://vpc.tf)

```plaintext
# AWS Provider Configuration

provider "aws" {
  region     = "ap-south-1"                 # AWS region (Mumbai)
  access_key = "my-access-key"              # Your AWS access key
  secret_key = "my-secret-key"              # Your AWS secret key
}

resource "aws_vpc" "main_vpc" {
  cidr_block = "10.0.0.0/16"            # Main network range for VPC

  tags = {
    Name = "main-vpc"                   # Name tag for identification
  }
}


resource "aws_subnet" "public_subnet" {
  vpc_id                  = aws_vpc.main_vpc.id       # Attach subnet to VPC
  cidr_block              = "10.0.1.0/24"             # Subnet range
  map_public_ip_on_launch = true                      # Auto-assign public IP

  tags = {
    Name = "public-subnet"                            # Tag for subnet
  }
}


resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main_vpc.id                   # Attach IGW to VPC

  tags = {
    Name = "main-igw"                            # Name tag
  }
}

                       
resource "aws_route_table" "public_rt" {
  vpc_id = aws_vpc.main_vpc.id                       # Attach RT to VPC

  route {
    cidr_block = "0.0.0.0/0"                         # All traffic
    gateway_id = aws_internet_gateway.igw.id         # Send to IGW
  }

  tags = {
    Name = "public-route-table"   # Tag for route table
  }
}

# Route Table Association
# Connect Subnet ‚Üí Route Table

resource "aws_route_table_association" "public_rt_assoc" {
  subnet_id      = aws_subnet.public_subnet.id                   # Which subnet?
  route_table_id = aws_route_table.public_rt.id                  # Which route table?
}
```

## 22\. Conclusion

Terraform is simple but powerful. By mastering resources, variables, modules, state, backends, and advanced concepts, you can manage any cloud infrastructure with confidence.

Use this guide as your foundation and keep practicing by building real projects like VPCs, EC2 setups, multi-tier architectures, and automated modules.